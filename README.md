# Лукьянов Илья, ПМИ-151 #

## Анализ видеопоследовательностей для поиска и выделения рекламы ##

### Актуальность задачи ###

* Существуют различные решения для поиска и удаления рекламных вставок из видеопотока, у всех есть свои преимущества и недостатки.
* Хотелось бы реализовать работающую с хорошей точностью утилиту для поиска рекламы, сохраняющее очищенный видеопоток "на лету".

### Используемые технологии ###

* Python — язык, с которым я себя комфортно чувствую, к тому же являющийся более или менее стандартом (вместе с C++) в анализе видео и изображений.
* OpenCV — одна из лучших библиотек компьютерного зрения.
* ffmpeg — пожалуй, лучшая утилита для обработки видео.
* numpy — хорошая библиотека для анализа данных для Python
* WebSockets — для визуализации работы в реальном времени в браузере

### Архитектура ###

![graph.png](https://bitbucket.org/ilyaluk/detect_ads/raw/master/graph.png)

Что происходит:

* Поток видео из какого-то источника (файлы, стрим, etc.) захватывается ffmpeg'ом, который запущен из `ffmpeg.py`.
* ffmpeg пережимает видео и отправляет его в несколько выходов:
  * `process.py` получает уменьшенное видео, ищет в каждом кадре точки интереса и при помощи `cut_detector.py` ищет границы сцен (по резким изменениям HSV).
  * И сам ffmpeg сохраняет видео в файл.
* `descriptor.py` получает от `process.py` границы сцен, точки интереса и их описания. Он описывает сцены маломерным вектором.
* `combinator.py` получает от `descriptor.py` описания сцен и ищет похожие сцены. При помощи некоторой магии для каждой сцены считается, реклама это или нет, и запускается ffmpeg для разрезания записи видео на рекламу и не-рекламу, которая потом объединяется в итоговое видео.
* Также параллельно с этим за процессом можно наблюдать в браузере и корректировать ошибки для последующего обучения. В браузер передаются сцены из `process.py` и отдаются изменения в `combinator.py`. Общение происходит через WebSockets.


### Как запустить ###

* Требуется OpenCV 3 (любой подойдёт, главное чтоб были биндинги для Python)
* Требуется ffmpeg
* Требуется numpy
* Бла-бла-бла

Когда более или менее закончу добавлять зависимости, разверну на чистой виртуалке с Ubuntu 16.04 и напишу подробную инструкцию для неё.
